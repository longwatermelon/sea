let READ_BUFFER_CAP:int = 5242880;
let WRITE_BUFFER_CAP:int = 32768;
let MOD:int = 1000000007;

let input_buffer:byte* = galloc(5242880, byte);
let input_index:int = 0;

let output_buffer:byte* = galloc(32768, byte);
let output_index:int = 0;

let str:byte* = galloc(1000008, byte);
let fact:int* = galloc(1000005, int);
let ifact:int* = galloc(1000005, int);

fn init_input() -> void {
    syscall(0,0,input_buffer,READ_BUFFER_CAP);
}

fn flush_output() -> void {
    if (output_index>0) {
        syscall(1,1,output_buffer,output_index);
        output_index = 0;
    }
}

fn read_char() -> int {
    if (input_index>=READ_BUFFER_CAP) {
        return 0;
    }
    let ch:int = input_buffer[input_index];
    input_index = input_index+1;
    return ch;
}

fn print_char(c:int) -> void {
    output_buffer[output_index] = c;
    output_index = output_index+1;
    if (output_index==WRITE_BUFFER_CAP) {
        flush_output();
    }
}

fn read_int() -> int {
    let ch:int = read_char();
    let res:int = 0;
    let neg:int = 0;

    while (ch==10 || ch==32 || ch==13) {
        ch = read_char();
    }

    if (ch==45) {
        neg = 1;
        ch = read_char();
    }

    while (ch!=10 && ch!=32 && ch!=13 && ch!=0) {
        res = res*10 + ch-48;
        ch = read_char();
    }

    if (neg==1) {
        return 0-res;
    }
    return res;
}

fn print_int(x:int) -> void {
    if (x==0) {
        print_char(48);
        return 0;
    }

    let neg:int = 0;
    if (x<0) {
        neg = 1;
        x = 0-x;
    }

    let arr:int* = stalloc(20,int);
    let ind:int = 0;
    while (x>0) {
        let rem:int = x%10;
        x = x/10;
        arr[ind] = rem+48;
        ind = ind+1;
    }

    if (neg==1) {
        print_char(45);
    }

    while (ind>0) {
        ind = ind-1;
        print_char(arr[ind]);
    }
}

fn read_string(dest:byte*, len:int) -> void {
    let idx:int = 0;
    let done:int = 0;
    while (idx<len && done==0) {
        let ch:int = read_char();
        if (ch==0) {
            done = 1;
        } else {
            let is_space:int = 0;
            if (ch==10 || ch==13 || ch==32) {
                is_space = 1;
            }
            if (is_space==0) {
                dest[idx] = ch;
                idx = idx+1;
            }
        }
    }
}

fn mod_pow(base:int, exp:int) -> int {
    let mut_base:int = base%MOD;
    if (mut_base<0) {
        mut_base = mut_base+MOD;
    }
    let result:int = 1;
    let current:int = mut_base;
    let exponent:int = exp;
    while (exponent>0) {
        if (exponent%2==1) {
            result = (result*current)%MOD;
        }
        current = (current*current)%MOD;
        exponent = exponent/2;
    }
    return result;
}

fn choose(n:int, k:int, fact:int*, ifact:int*) -> int {
    if (k<0 || k>n) {
        return 0;
    }
    let res:int = fact[n];
    let temp:int = (res*ifact[k])%MOD;
    return (temp*ifact[n-k])%MOD;
}

fn main() -> int {
    init_input();

    let K:int = read_int();
    let N:int = read_int();
    let L:int = read_int();

    read_string(str, N);

    let total_M:int = 0;
    let total_O:int = 0;

    let idx:int = 0;
    while (idx<N) {
        if (str[idx]==77) {
            total_M = total_M+1;
        } else {
            total_O = total_O+1;
        }
        idx = idx+1;
    }

    if (total_O!=K*total_M) {
        print_int(0);
        print_char(10);
        flush_output();
        return 0;
    }

    let limit:int = total_O;

    fact[0] = 1;
    let f:int = 1;
    while (f<=limit) {
        fact[f] = (fact[f-1]*f)%MOD;
        f = f+1;
    }

    ifact[limit] = mod_pow(fact[limit], MOD-2);
    let g:int = limit;
    while (g>0) {
        ifact[g-1] = (ifact[g]*g)%MOD;
        g = g-1;
    }

    let suffix_M:int = 0;
    let suffix_O:int = 0;
    let prod:int = 1;

    let pos:int = N-1;
    while (pos>=0 && prod!=0) {
        let ch:int = str[pos];
        if (ch==79) {
            suffix_O = suffix_O+1;
        } else {
            let value:int = suffix_O - K*suffix_M;
            let bad:int = 0;
            if (value<K || value<0) {
                bad = 1;
            }
            if (bad==0) {
                let comb:int = choose(value, K, fact, ifact);
                prod = (prod*comb)%MOD;
                suffix_M = suffix_M+1;
            } else {
                prod = 0;
            }
        }
        pos = pos-1;
    }

    let answer:int = mod_pow(prod, L);
    print_int(answer);
    print_char(10);
    flush_output();
}
