#include "rbtree.h"
#include "malloc.h"

fn node_color(n:RbNode*) -> int {
    if (n==0) { return 0; }
    return (*n).color;
}

fn set_node_color(n:RbNode*, c:int) -> void {
    if (n==0) { return 0; }
    (*n).color = c;
}

fn node_new(k:int, v:int) -> RbNode* {
    let n:RbNode* = malloc(6*sizeof(int));
    if (n==0) { return 0; }
    (*n).key = k;
    (*n).val = v;
    (*n).color = 1; // red
    (*n).left = 0;
    (*n).right = 0;
    (*n).parent = 0;
    return n;
}

fn left_rotate(t:RbTree*, x:RbNode*) -> void {
    if (x==0) { return 0; }
    let y:RbNode* = (*x).right;
    if (y==0) { return 0; }
    let yleft:RbNode* = (*y).left;
    (*x).right = yleft;
    if (yleft!=0) { (*yleft).parent = x; }
    let p:RbNode* = (*x).parent;
    (*y).parent = p;
    if (p==0) {
        (*t).root = y;
    } else {
        if (x==(*p).left) { (*p).left = y; }
        else { (*p).right = y; }
    }
    (*y).left = x;
    (*x).parent = y;
}

fn right_rotate(t:RbTree*, x:RbNode*) -> void {
    if (x==0) { return 0; }
    let y:RbNode* = (*x).left;
    if (y==0) { return 0; }
    let yright:RbNode* = (*y).right;
    (*x).left = yright;
    if (yright!=0) { (*yright).parent = x; }
    let p:RbNode* = (*x).parent;
    (*y).parent = p;
    if (p==0) {
        (*t).root = y;
    } else {
        if (x==(*p).left) { (*p).left = y; }
        else { (*p).right = y; }
    }
    (*y).right = x;
    (*x).parent = y;
}

fn tree_min(n:RbNode*) -> RbNode* {
    if (n==0) { return 0; }
    let x:RbNode* = n;
    while ((*x).left!=0) { x = (*x).left; }
    return x;
}

fn tree_max(n:RbNode*) -> RbNode* {
    if (n==0) { return 0; }
    let x:RbNode* = n;
    while ((*x).right!=0) { x = (*x).right; }
    return x;
}

fn rb_insert_fix(t:RbTree*, z:RbNode*) -> void {
    while (1) {
        let p:RbNode* = 0;
        if (z!=0) { p = (*z).parent; }
        if (node_color(p) != 1) { break; }
        let gp:RbNode* = 0;
        if (p!=0) { gp = (*p).parent; }
        if (gp==0) { break; }
        if (p==(*gp).left) {
            let y:RbNode* = (*gp).right;
            if (node_color(y)==1) {
                set_node_color(p, 0);
                set_node_color(y, 0);
                set_node_color(gp, 1);
                z = gp;
            } else {
                if (z==(*p).right) {
                    z = p;
                    left_rotate(t, z);
                    p = (*z).parent;
                    if (p!=0) { gp = (*p).parent; }
                }
                set_node_color((*z).parent, 0);
                if (gp!=0) { set_node_color(gp, 1); right_rotate(t, gp); }
            }
        } else {
            let y2:RbNode* = (*gp).left;
            if (node_color(y2)==1) {
                set_node_color(p, 0);
                set_node_color(y2, 0);
                set_node_color(gp, 1);
                z = gp;
            } else {
                if (z==(*p).left) {
                    z = p;
                    right_rotate(t, z);
                    p = (*z).parent;
                    if (p!=0) { gp = (*p).parent; }
                }
                set_node_color((*z).parent, 0);
                if (gp!=0) { set_node_color(gp, 1); left_rotate(t, gp); }
            }
        }
    }
    if ((*t).root!=0) { set_node_color((*t).root, 0); }
}

fn transplant(t:RbTree*, u:RbNode*, v:RbNode*) -> void {
    let p:RbNode* = (*u).parent;
    if (p==0) {
        (*t).root = v;
    } else {
        if (u==(*p).left) { (*p).left = v; }
        else { (*p).right = v; }
    }
    if (v!=0) { (*v).parent = p; }
}

fn rb_delete_fix(t:RbTree*, x:RbNode*, x_parent:RbNode*) -> void {
    while (1) {
        if (x==(*t).root) { break; }
        if (node_color(x)!=0) { break; }
        let xp:RbNode* = x_parent;
        if (xp==0) { break; }
        if (x==(*xp).left) {
            let w:RbNode* = (*xp).right;
            if (node_color(w)==1) {
                set_node_color(w, 0);
                set_node_color(xp, 1);
                left_rotate(t, xp);
                w = (*xp).right;
            }
            let wl:RbNode* = 0;
            let wr:RbNode* = 0;
            if (w!=0) { wl = (*w).left; wr = (*w).right; }
            if (node_color(wl)==0 && node_color(wr)==0) {
                set_node_color(w, 1);
                x = xp;
                x_parent = (*x).parent;
            } else {
                if (node_color(wr)==0) {
                    set_node_color(wl, 0);
                    set_node_color(w, 1);
                    right_rotate(t, w);
                    w = (*xp).right;
                }
                set_node_color(w, node_color(xp));
                set_node_color(xp, 0);
                let wrr:RbNode* = 0;
                if (w!=0) { wrr = (*w).right; }
                set_node_color(wrr, 0);
                left_rotate(t, xp);
                x = (*t).root;
                x_parent = 0;
            }
        } else {
            let w2:RbNode* = (*xp).left;
            if (node_color(w2)==1) {
                set_node_color(w2, 0);
                set_node_color(xp, 1);
                right_rotate(t, xp);
                w2 = (*xp).left;
            }
            let w2l:RbNode* = 0;
            let w2r:RbNode* = 0;
            if (w2!=0) { w2l = (*w2).left; w2r = (*w2).right; }
            if (node_color(w2l)==0 && node_color(w2r)==0) {
                set_node_color(w2, 1);
                x = xp;
                x_parent = (*x).parent;
            } else {
                if (node_color(w2l)==0) {
                    set_node_color(w2r, 0);
                    set_node_color(w2, 1);
                    left_rotate(t, w2);
                    w2 = (*xp).left;
                }
                set_node_color(w2, node_color(xp));
                set_node_color(xp, 0);
                let w2l2:RbNode* = 0;
                if (w2!=0) { w2l2 = (*w2).left; }
                set_node_color(w2l2, 0);
                right_rotate(t, xp);
                x = (*t).root;
                x_parent = 0;
            }
        }
    }
    set_node_color(x, 0);
}

fn rbtree_new() -> RbTree* {
    let t:RbTree* = malloc(4*sizeof(int));
    if (t==0) { return 0; }
    (*t).len = 0;
    (*t).root = 0;
    (*t).min = 0;
    (*t).max = 0;
    return t;
}

fn free_nodes(n:RbNode*) -> void {
    if (n==0) { return 0; }
    let l:RbNode* = (*n).left;
    let r:RbNode* = (*n).right;
    if (l!=0) { free_nodes(l); }
    if (r!=0) { free_nodes(r); }
    free(n);
}

fn rbtree_free(t:RbTree*) -> void {
    if (t==0) { return 0; }
    if ((*t).root!=0) { free_nodes((*t).root); }
    free(t);
}

fn rbtree_size(t:RbTree*) -> int {
    if (t==0) { return 0; }
    return (*t).len;
}

fn find_node(t:RbTree*, k:int) -> RbNode* {
    if (t==0) { return 0; }
    let cur:RbNode* = (*t).root;
    while (cur!=0) {
        if (k<(*cur).key) { cur = (*cur).left; }
        else if (k>(*cur).key) { cur = (*cur).right; }
        else { return cur; }
    }
    return 0;
}

fn rbtree_contains(t:RbTree*, k:int) -> int {
    if (t==0) { return 0; }
    let n:RbNode* = find_node(t, k);
    if (n==0) { return 0; }
    return 1;
}

fn rbtree_get(t:RbTree*, k:int) -> int {
    let n:RbNode* = find_node(t, k);
    if (n==0) { return 0; }
    return (*n).val;
}

fn rbtree_set(t:RbTree*, k:int, v:int) -> int {
    if (t==0) { return 0; }
    let cur:RbNode* = (*t).root;
    let y:RbNode* = 0;
    while (cur!=0) {
        y = cur;
        if (k<(*cur).key) { cur = (*cur).left; }
        else if (k>(*cur).key) { cur = (*cur).right; }
        else {
            (*cur).val = v;
            return 0;
        }
    }
    let z:RbNode* = node_new(k, v);
    if (z==0) { return 0; }
    (*z).parent = y;
    if (y==0) { (*t).root = z; }
    else if (k<(*y).key) { (*y).left = z; }
    else { (*y).right = z; }
    rb_insert_fix(t, z);
    (*t).len = (*t).len + 1;
    // update cached min/max pointers without short-circuiting
    if (y==0) {
        (*t).min = z;
        (*t).max = z;
    } else {
        let mn:RbNode* = (*t).min;
        if (mn==0) { (*t).min = z; }
        else {
            if (k < (*mn).key) { (*t).min = z; }
        }
        let mx:RbNode* = (*t).max;
        if (mx==0) { (*t).max = z; }
        else {
            if (k > (*mx).key) { (*t).max = z; }
        }
    }
    return 1;
}

fn rbtree_erase(t:RbTree*, k:int) -> int {
    if (t==0) { return 0; }
    let z:RbNode* = find_node(t, k);
    if (z==0) { return 0; }
    let was_min:int = 0;
    let was_max:int = 0;
    if ((*t).min == z) { was_min = 1; }
    if ((*t).max == z) { was_max = 1; }
    let y:RbNode* = z;
    let y_orig:int = node_color(y);
    let xnode:RbNode* = 0;
    let xparent:RbNode* = 0;
    if ((*z).left==0) {
        xnode = (*z).right;
        xparent = (*z).parent;
        transplant(t, z, (*z).right);
    } else if ((*z).right==0) {
        xnode = (*z).left;
        xparent = (*z).parent;
        transplant(t, z, (*z).left);
    } else {
        y = tree_min((*z).right);
        y_orig = node_color(y);
        xnode = (*y).right;
        if ((*y).parent == z) {
            xparent = y;
            if (xnode!=0) { (*xnode).parent = y; }
        } else {
            xparent = (*y).parent;
            transplant(t, y, (*y).right);
            (*y).right = (*z).right;
            if ((*y).right!=0) { (*(*y).right).parent = y; }
        }
        transplant(t, z, y);
        (*y).left = (*z).left;
        if ((*y).left!=0) { (*(*y).left).parent = y; }
        (*y).color = (*z).color;
    }
    free(z);
    (*t).len = (*t).len - 1;
    if (y_orig==0) { rb_delete_fix(t, xnode, xparent); }
    // fix cached min/max
    if ((*t).root==0) {
        (*t).min = 0;
        (*t).max = 0;
    } else {
        if (was_min==1) { (*t).min = tree_min((*t).root); }
        if (was_max==1) { (*t).max = tree_max((*t).root); }
    }
    return 1;
}

fn rbtree_min_key(t:RbTree*) -> int {
    if (t==0) { return 0; }
    let n:RbNode* = (*t).min;
    if (n==0) { return 0; }
    return (*n).key;
}

fn rbtree_max_key(t:RbTree*) -> int {
    if (t==0) { return 0; }
    let n:RbNode* = (*t).max;
    if (n==0) { return 0; }
    return (*n).key;
}

fn rbtree_begin(t:RbTree*) -> RbNode* {
    if (t==0) { return 0; }
    return (*t).min;
}

fn rbtree_next(n:RbNode*) -> RbNode* {
    if (n==0) { return 0; }
    if ((*n).right!=0) {
        return tree_min((*n).right);
    }
    let p:RbNode* = (*n).parent;
    let x:RbNode* = n;
    while (1) {
        if (p==0) { break; }
        if (x!=(*p).right) { break; }
        x = p;
        p = (*p).parent;
    }
    return p;
}

fn rbtree_node_key(n:RbNode*) -> int { if (n==0) { return 0; } return (*n).key; }
fn rbtree_node_val(n:RbNode*) -> int { if (n==0) { return 0; } return (*n).val; }
