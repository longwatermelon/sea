// Map implemented as thin wrappers around the generic RB-tree.
#include "map.h"
#include "rbtree.h"
#include "malloc.h"

fn map_new() -> Map* {
    let m:Map* = malloc(1*sizeof(int));
    if (m==0) { return 0; }
    (*m).tree = rbtree_new();
    return m;
}

fn map_free(m:Map*) -> void {
    if (m==0) { return 0; }
    if ((*m).tree!=0) { rbtree_free((*m).tree); }
    free(m);
}

fn map_size(m:Map*) -> int {
    if (m==0) { return 0; }
    return rbtree_size((*m).tree);
}

fn map_contains(m:Map*, k:int) -> int {
    if (m==0) { return 0; }
    return rbtree_contains((*m).tree, k);
}

fn map_get(m:Map*, k:int) -> int {
    return rbtree_get((*m).tree, k);
}

fn map_set(m:Map*, k:int, v:int) -> void {
    if (m==0) { return 0; }
    let _inserted:int = rbtree_set((*m).tree, k, v);
    return 0;
}

fn map_erase(m:Map*, k:int) -> int {
    if (m==0) { return 0; }
    return rbtree_erase((*m).tree, k);
}

fn map_min_key(m:Map*) -> int {
    if (m==0) { return 0; }
    return rbtree_min_key((*m).tree);
}

fn map_max_key(m:Map*) -> int {
    if (m==0) { return 0; }
    return rbtree_max_key((*m).tree);
}

fn map_begin(m:Map*) -> MapNode* {
    if (m==0) { return 0; }
    return rbtree_begin((*m).tree);
}

fn map_next(n:MapNode*) -> MapNode* {
    if (n==0) { return 0; }
    return rbtree_next(n);
}

fn map_node_key(n:MapNode*) -> int {
    return rbtree_node_key(n);
}

fn map_node_val(n:MapNode*) -> int {
    return rbtree_node_val(n);
}
