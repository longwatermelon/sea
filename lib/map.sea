#include "map.h"
#include "malloc.h"

fn node_color_m(n:MapNode*) -> int {
    if (n==0) { return 0; }
    return (*n).color;
}

fn set_node_color_m(n:MapNode*, c:int) -> void {
    if (n==0) { return 0; }
    (*n).color = c;
}

fn node_new_m(k:int, v:int) -> MapNode* {
    let n:MapNode* = malloc(6*sizeof(int));
    if (n==0) { return 0; }
    (*n).key = k;
    (*n).val = v;
    (*n).color = 1;
    (*n).left = 0;
    (*n).right = 0;
    (*n).parent = 0;
    return n;
}

fn left_rotate_m(m:Map*, x:MapNode*) -> void {
    if (x==0) { return 0; }
    let y:MapNode* = (*x).right;
    if (y==0) { return 0; }
    let yleft:MapNode* = (*y).left;
    (*x).right = yleft;
    if (yleft!=0) { (*yleft).parent = x; }
    let p:MapNode* = (*x).parent;
    (*y).parent = p;
    if (p==0) {
        (*m).root = y;
    } else {
        if (x==(*p).left) { (*p).left = y; }
        else { (*p).right = y; }
    }
    (*y).left = x;
    (*x).parent = y;
}

fn right_rotate_m(m:Map*, x:MapNode*) -> void {
    if (x==0) { return 0; }
    let y:MapNode* = (*x).left;
    if (y==0) { return 0; }
    let yright:MapNode* = (*y).right;
    (*x).left = yright;
    if (yright!=0) { (*yright).parent = x; }
    let p:MapNode* = (*x).parent;
    (*y).parent = p;
    if (p==0) {
        (*m).root = y;
    } else {
        if (x==(*p).left) { (*p).left = y; }
        else { (*p).right = y; }
    }
    (*y).right = x;
    (*x).parent = y;
}

fn tree_min_m(n:MapNode*) -> MapNode* {
    if (n==0) { return 0; }
    let x:MapNode* = n;
    while ((*x).left!=0) { x = (*x).left; }
    return x;
}

fn tree_max_m(n:MapNode*) -> MapNode* {
    if (n==0) { return 0; }
    let x:MapNode* = n;
    while ((*x).right!=0) { x = (*x).right; }
    return x;
}

fn rb_insert_fix_m(m:Map*, z:MapNode*) -> void {
    while (1) {
        let p:MapNode* = 0;
        if (z!=0) { p = (*z).parent; }
        if (node_color_m(p) != 1) { break; }
        let gp:MapNode* = 0;
        if (p!=0) { gp = (*p).parent; }
        if (gp==0) { break; }
        if (p==(*gp).left) {
            let y:MapNode* = (*gp).right;
            if (node_color_m(y)==1) {
                set_node_color_m(p, 0);
                set_node_color_m(y, 0);
                set_node_color_m(gp, 1);
                z = gp;
            } else {
                if (z==(*p).right) {
                    z = p;
                    left_rotate_m(m, z);
                    p = (*z).parent;
                    if (p!=0) { gp = (*p).parent; }
                }
                set_node_color_m((*z).parent, 0);
                if (gp!=0) { set_node_color_m(gp, 1); right_rotate_m(m, gp); }
            }
        } else {
            let y2:MapNode* = (*gp).left;
            if (node_color_m(y2)==1) {
                set_node_color_m(p, 0);
                set_node_color_m(y2, 0);
                set_node_color_m(gp, 1);
                z = gp;
            } else {
                if (z==(*p).left) {
                    z = p;
                    right_rotate_m(m, z);
                    p = (*z).parent;
                    if (p!=0) { gp = (*p).parent; }
                }
                set_node_color_m((*z).parent, 0);
                if (gp!=0) { set_node_color_m(gp, 1); left_rotate_m(m, gp); }
            }
        }
    }
    if ((*m).root!=0) { set_node_color_m((*m).root, 0); }
}

fn transplant_m(m:Map*, u:MapNode*, v:MapNode*) -> void {
    let p:MapNode* = (*u).parent;
    if (p==0) {
        (*m).root = v;
    } else {
        if (u==(*p).left) { (*p).left = v; }
        else { (*p).right = v; }
    }
    if (v!=0) { (*v).parent = p; }
}

fn rb_delete_fix_m(m:Map*, x:MapNode*, x_parent:MapNode*) -> void {
    while (1) {
        if (x==(*m).root) { break; }
        if (node_color_m(x)!=0) { break; }
        let xp:MapNode* = x_parent;
        if (xp==0) { break; }
        if (x==(*xp).left) {
            let w:MapNode* = (*xp).right;
            if (node_color_m(w)==1) {
                set_node_color_m(w, 0);
                set_node_color_m(xp, 1);
                left_rotate_m(m, xp);
                w = (*xp).right;
            }
            let wl:MapNode* = 0;
            let wr:MapNode* = 0;
            if (w!=0) { wl = (*w).left; wr = (*w).right; }
            if (node_color_m(wl)==0 && node_color_m(wr)==0) {
                set_node_color_m(w, 1);
                x = xp;
                x_parent = (*x).parent;
            } else {
                if (node_color_m(wr)==0) {
                    set_node_color_m(wl, 0);
                    set_node_color_m(w, 1);
                    right_rotate_m(m, w);
                    w = (*xp).right;
                }
                set_node_color_m(w, node_color_m(xp));
                set_node_color_m(xp, 0);
                let wrr:MapNode* = 0;
                if (w!=0) { wrr = (*w).right; }
                set_node_color_m(wrr, 0);
                left_rotate_m(m, xp);
                x = (*m).root;
                x_parent = 0;
            }
        } else {
            let w2:MapNode* = (*xp).left;
            if (node_color_m(w2)==1) {
                set_node_color_m(w2, 0);
                set_node_color_m(xp, 1);
                right_rotate_m(m, xp);
                w2 = (*xp).left;
            }
            let w2l:MapNode* = 0;
            let w2r:MapNode* = 0;
            if (w2!=0) { w2l = (*w2).left; w2r = (*w2).right; }
            if (node_color_m(w2l)==0 && node_color_m(w2r)==0) {
                set_node_color_m(w2, 1);
                x = xp;
                x_parent = (*x).parent;
            } else {
                if (node_color_m(w2l)==0) {
                    set_node_color_m(w2r, 0);
                    set_node_color_m(w2, 1);
                    left_rotate_m(m, w2);
                    w2 = (*xp).left;
                }
                set_node_color_m(w2, node_color_m(xp));
                set_node_color_m(xp, 0);
                let w2l2:MapNode* = 0;
                if (w2!=0) { w2l2 = (*w2).left; }
                set_node_color_m(w2l2, 0);
                right_rotate_m(m, xp);
                x = (*m).root;
                x_parent = 0;
            }
        }
    }
    set_node_color_m(x, 0);
}

fn map_new() -> Map* {
    let m:Map* = malloc(2*sizeof(int));
    if (m==0) { return 0; }
    (*m).len = 0;
    (*m).root = 0;
    return m;
}

fn free_nodes_m(n:MapNode*) -> void {
    if (n==0) { return 0; }
    let l:MapNode* = (*n).left;
    let r:MapNode* = (*n).right;
    if (l!=0) { free_nodes_m(l); }
    if (r!=0) { free_nodes_m(r); }
    free(n);
}

fn map_free(m:Map*) -> void {
    if (m==0) { return 0; }
    if ((*m).root!=0) { free_nodes_m((*m).root); }
    free(m);
}

fn map_size(m:Map*) -> int {
    if (m==0) { return 0; }
    return (*m).len;
}

fn map_contains(m:Map*, k:int) -> int {
    if (m==0) { return 0; }
    let cur:MapNode* = (*m).root;
    while (cur!=0) {
        if (k<(*cur).key) { cur = (*cur).left; }
        else if (k>(*cur).key) { cur = (*cur).right; }
        else { return 1; }
    }
    return 0;
}

fn find_node_m(m:Map*, k:int) -> MapNode* {
    if (m==0) { return 0; }
    let cur:MapNode* = (*m).root;
    while (cur!=0) {
        if (k<(*cur).key) { cur = (*cur).left; }
        else if (k>(*cur).key) { cur = (*cur).right; }
        else { return cur; }
    }
    return 0;
}

fn map_get(m:Map*, k:int) -> int {
    let n:MapNode* = find_node_m(m, k);
    if (n==0) { return 0; }
    return (*n).val;
}

fn map_set(m:Map*, k:int, v:int) -> void {
    if (m==0) { return 0; }
    let cur:MapNode* = (*m).root;
    let y:MapNode* = 0;
    while (cur!=0) {
        y = cur;
        if (k<(*cur).key) { cur = (*cur).left; }
        else if (k>(*cur).key) { cur = (*cur).right; }
        else {
            (*cur).val = v;
            return 0;
        }
    }
    let z:MapNode* = node_new_m(k, v);
    if (z==0) { return 0; }
    (*z).parent = y;
    if (y==0) { (*m).root = z; }
    else if (k<(*y).key) { (*y).left = z; }
    else { (*y).right = z; }
    rb_insert_fix_m(m, z);
    (*m).len = (*m).len + 1;
}

fn map_erase(m:Map*, k:int) -> int {
    if (m==0) { return 0; }
    let z:MapNode* = find_node_m(m, k);
    if (z==0) { return 0; }
    let y:MapNode* = z;
    let y_orig:int = node_color_m(y);
    let xnode:MapNode* = 0;
    let xparent:MapNode* = 0;
    if ((*z).left==0) {
        xnode = (*z).right;
        xparent = (*z).parent;
        transplant_m(m, z, (*z).right);
    } else if ((*z).right==0) {
        xnode = (*z).left;
        xparent = (*z).parent;
        transplant_m(m, z, (*z).left);
    } else {
        y = tree_min_m((*z).right);
        y_orig = node_color_m(y);
        xnode = (*y).right;
        if ((*y).parent == z) {
            xparent = y;
            if (xnode!=0) { (*xnode).parent = y; }
        } else {
            xparent = (*y).parent;
            transplant_m(m, y, (*y).right);
            (*y).right = (*z).right;
            if ((*y).right!=0) { (*(*y).right).parent = y; }
        }
        transplant_m(m, z, y);
        (*y).left = (*z).left;
        if ((*y).left!=0) { (*(*y).left).parent = y; }
        (*y).color = (*z).color;
    }
    free(z);
    (*m).len = (*m).len - 1;
    if (y_orig==0) { rb_delete_fix_m(m, xnode, xparent); }
    return 1;
}

fn map_min_key(m:Map*) -> int {
    if (m==0) { return 0; }
    if ((*m).root==0) { return 0; }
    let n:MapNode* = tree_min_m((*m).root);
    if (n==0) { return 0; }
    return (*n).key;
}

fn map_max_key(m:Map*) -> int {
    if (m==0) { return 0; }
    if ((*m).root==0) { return 0; }
    let n:MapNode* = tree_max_m((*m).root);
    if (n==0) { return 0; }
    return (*n).key;
}

fn map_begin(m:Map*) -> MapNode* {
    if (m==0) { return 0; }
    if ((*m).root==0) { return 0; }
    return tree_min_m((*m).root);
}

fn map_next(n:MapNode*) -> MapNode* {
    if (n==0) { return 0; }
    if ((*n).right!=0) {
        return tree_min_m((*n).right);
    }
    let p:MapNode* = (*n).parent;
    let x:MapNode* = n;
    while (1) {
        if (p==0) { break; }
        if (x!=(*p).right) { break; }
        x = p;
        p = (*p).parent;
    }
    return p;
}

fn map_node_key(n:MapNode*) -> int {
    if (n==0) { return 0; }
    return (*n).key;
}

fn map_node_val(n:MapNode*) -> int {
    if (n==0) { return 0; }
    return (*n).val;
}
